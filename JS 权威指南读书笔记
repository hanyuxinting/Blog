第四章

1. 原始表达式-primary expression
表达式的原子级别。最小。常量/直接量、关键字、变量。
常量/直接量：1.23、'hello'、/pattern/----back to part3\10
关键字/js的一些保留字：true false null this
变量：i、sum、 undefined 当变量不存在时，表达式运算结果为undefined

2. 对象和数组的初始化表达式-对象直接量\数组直接量-新创建的对象和数组
不同于布尔直接量，非原始表达式，含有子表达式。
数组初始化表达式：[]、[1+2, 3+4]、[[1,2,3].[2,3,4]]、
[1,,,,,5] 这种中间空位会被填充为 undefined。


对象表达式：


3. 函数定义表达式-函数直接量-function
定义一个js函数。
以下代码中可以区别函数直接量和函数。
函数后不用加; 而函数直接量需要加;区分是声明变量结束。


4. 属性访问表达式-得到一个对象属性、或数组元素的值。（第六章）
. 运算和[]运算
先计算.\[]运算符前的表达式，若为null或undefined，则抛出异常。so，经常用obj&&obj.x
这种语句判断。属性不存在，则返回undefined。
点运算符只适用要访问的属性名称是合法的标识符，且需要知道要访问的属性名。
用$.each可以遍历属性。
若属性名为保留字或包含空格和标点或是数字（数组而言），须使用方括号。
属性名是运算得出的值而不是固定值时，须用方括号。
对象属性：


数组属性：


5. 调用表达式-调用函数或方法。（第八章）
若函数使用return语句，则这个返回值为整个调用表达式的值。否则为undefined。
方法调用是针对一个对象里的方法而言。其实最终都是函数了~~（第九章）
普通函数调用，通常使用全局对象作为this的值，ES5严格模式下，this值为undefined。
了解严格模式 5.7.3

6. 对象创建表达式-创建一个对象并调用构造函数初始化新对象的属性。
new Object()/new Object
new Point(1,2)/new Point(1,2)

7. 运算符概述-关键字运算符、标点运算符。
delete
instanceof



delete 删除属性


x = 42;        // 隐式声明的全局变量
var y = 43;    // 显式声明的全局变量
myobj = {
  h: 4,    
  k: 5
}    

// 隐式声明的全局变量可以被删除
delete x;       // 返回 true 

// 显式声明的全局变量不能被删除,该属性不可配置（not configurable）
delete y;       // 返回 false 

//内置对象的内置属性不能被删除
delete Math.PI; // 返回 false

//用户定义的属性可以被删除
delete myobj.h; // 返回 true 

// myobj 是全局对象的属性，而不是变量
//因此可以被删除
delete myobj;   // 返回 true

function f() {
  var z = 44;

  // delete doesn't affect local variable names
  delete z;     // returns false
}


// Numbers
typeof 37 === 'number';
typeof 3.14 === 'number';
typeof Math.LN2 === 'number';
typeof Infinity === 'number';
typeof NaN === 'number'; // 尽管NaN是"Not-A-Number"的缩写
typeof Number(1) === 'number'; // 但不要使用这种形式!

// Strings
typeof "" === 'string';
typeof "bla" === 'string';
typeof (typeof 1) === 'string'; // typeof总是返回一个字符串
typeof String("abc") === 'string'; // 但不要使用这种形式!

// Booleans
typeof true === 'boolean';
typeof false === 'boolean';
typeof Boolean(true) === 'boolean'; // 但不要使用这种形式!

// Symbols
typeof Symbol() === 'symbol';
typeof Symbol('foo') === 'symbol';
typeof Symbol.iterator === 'symbol';

// Undefined
typeof undefined === 'undefined';
typeof declaredButUndefinedVariable === 'undefined';
typeof undeclaredVariable === 'undefined'; 

// Objects
typeof {a:1} === 'object';

// 使用Array.isArray 或者 Object.prototype.toString.call
// 区分数组,普通对象
typeof [1, 2, 4] === 'object';

typeof new Date() === 'object';

// 下面的容易令人迷惑，不要使用！
typeof new Boolean(true) === 'object';
typeof new Number(1) ==== 'object';
typeof new String("abc") === 'object';

// 函数
typeof function(){} === 'function';
typeof Math.sin === 'function';

// 定义构造函数
function C(){} 
function D(){} 

var o = new C();

// true，因为 Object.getPrototypeOf(o) === C.prototype
o instanceof C; 

// false，因为 D.prototype不在o的原型链上
o instanceof D; 

o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true
C.prototype instanceof Object // true,同上

C.prototype = {};
var o2 = new C();

o2 instanceof C; // true

o instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.

D.prototype = new C(); // 继承
var o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true


// 数组
var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
0 in trees        // 返回true
3 in trees        // 返回true
6 in trees        // 返回false
"bay" in trees    // 返回false (必须使用索引号,而不是数组元素的值)
"length" in trees // 返回true (length是一个数组属性)

// 内置对象
"PI" in Math          // 返回true

// 自定义对象
var mycar = {make: "Honda", model: "Accord", year: 1998};
"make" in mycar  // 返回true
"model" in mycar // 返回true

var color1 = new String("green");
"length" in color1 // 返回true
var color2 = "coral";
"length" in color2 // 报错(color2不是对象)

var mycar = {make: "Honda", model: "Accord", year: 1998};
delete mycar.make;
"make" in mycar;  // 返回false

var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
delete trees[3];
3 in trees; // 返回false

当你删除一个数组元素时，数组的 length 属性并不会变小。


8. 算术表达式
+ 优先考虑字符串连接，然后才是加法运算。

9.关系表达式

10. 逻辑表达式
11. 赋值表达式
12. 表达式计算
13. 其他运算符


